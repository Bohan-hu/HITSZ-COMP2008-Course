# 三、实验背景

我们已经在组成原理的课程中，学习过两种控制器：组合逻辑控制器和微程序控制器。微程序控制器不直接使用组合逻辑和时序逻辑产生控制信号，而是将 **控制信号** 放在一个ROM中，在指令执行时，按照 **正确的次序** 去访问ROM中相应的存储单元，取出相应的微指令来控制执行各个微操作。

我们首先需要明确的是，任何复杂或简单的CPU系统，都是一个有限状态机。微程序控制器的输出也是如此。它开始于某个状态，在输入的数据（指令操作码和标识符等）的作用下，转移到另一个状态（输出不同的控制信号）。~~（暗号：天）~~

## 3.1 如何设计一个简单的CPU？

要设计一个CPU，我们首先需要设计一个简单的 **指令系统** ，然后根据该系统，搭建对的 **数据通路** ，然后在数据通路的基础上，实现我们的控制逻辑。

在这个实验中，我们已经完成了数据通路的设计，你所需要做的，只是设计相应的控制逻辑，控制数据通路的建立，驱动CPU正常地执行指令。

## 3.2 定义指令集

我们设计的CPU具有以下几个寄存器：

> PC：指令指针
>
> IR：指令寄存器
>
> MAR：内存地址寄存器
>
> MDR：内存数据寄存器
>
> ACC：累加寄存器
>
> SP：栈顶寄存器
>
> R：通用寄存器

其余参数如下：

- 机器字长为1个字节，8位
- 所有的寄存器宽度均为8位



正如每个厂家都会定义一套自己的指令集，如Intel和AMD的x86-64，arm的ARM，IBM的Power，我们将这次实现的CPU支持的指令集称为 **awsI** （  **a** dvanced  **w** asted  **s** imple  **I** nstruction set）， **awsI** 指令集包括整数移动指令、访存指令、条件跳转指令、无条件跳转指令、算术逻辑指令：

| 指令编码（不定长指令） | 指令       | 功能                    |
| -------------- | ---------- | ----------------------- |
| 00000000       | NOP        | 空操作                  |
| 00100000 [ADDR] | LOAD ADDR  | ACC  ←  M[ ADDR ]       |
| 00110000 [ADDR] | STORE ADDR | M[ ADDR ] ← ACC         |
| 01000000       | MOVE       | R  ← ACC                |
| 01010000       | ADD        | ACC  ←  ACC + R         |
| 01100000       | AND        | ACC  ←  ACC and R       |
| 01110000 [IMM] | JUMP IMM   | PC ← IMM                |
| 10000000 [IMM] | JUMPZ IMM  | if (ACC == 0) then PC ← IMM |
| 10010000 [IMM] | JUMPNZ IMM  | if (ACC != 0) then PC ← IMM |
| 10100000 [IMM] | LOADR IMM  | R ← IMM |

- 指令为 **不定长指令** ，其中，指令的第一个字节的高4位编码为操作码，可由操作码 **唯一** 识别出指令；指令第一个字节低4位保留，默认全部为0.~~（暗号：王）~~。
- 若指令编码后有[IMM]或是[ADDR]字段，则代表是2字长指令。
- 若为2字长指令，则第二个字节为相关的立即数或是内存地址。



**同时，提供3条可选指令，作为附加题供同学们完成。**

| 指令编码      | 指令       | 功能          |
| ------------- | ---------- | ------------- |
| 11000000[IMM] | LOADSP IMM | SP ← IMM      |
| 11010000      | PUSH       | M[--SP]  ←  R |
| 11100000      | POP        | R  ←  M[SP++] |

附加指令不提供测试，请自行编写测试，并在实验报告中体现你的实现思路和测试代码，并附上测试截图。


